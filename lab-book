1/
create-react-app kanban-test

2/
npm i ? npm start ?
npm i -S react-dnd react-dnd-html5-backend react-redux

* got an enoent error from terminal upon restarting server:
  yarn start
  => $ react-scripts start
  => /bin/sh: react-scripts: command not found
  => error Command failed with exit code 127.
* fixed by running npm i again
* weeeerd



3/
* setup a DragDropContext in Board


4/
* declare a Column as presentational with children
* Board renders 2x <Column />

5/
* create a .renderColumn() in Board to render columns
* inside .renderColumn() give columns a key and .cid props
* create array and populate it with 2x .renderColumn() outputs using a for-loop
* render() array

6/
* create constants.js and specify itemTypes.LIST
* declare List and set it up as DragSource
* modify .renderColumn() in Board to return <Column /><List /></Column>

7/
* decide on state tree architecture; thus, declare initial state
* declare reducer named kanban that simply only returns state
* declare mapStateToProps on Board => return cols and lists from state
* subscribe Board to redux store
* set top limit in for-loop in render() in Board to this.props.cols (based on state.cols; check out to mapStateToProps)

8/
* declare .renderList() in Board to render lists with .lid prop
* renderColumn now has to accept 2 params: cid, lid
* modify .renderColumn() in Board to return <Column /> { this.renderList(futureListIdProp) } </Column>
* modify List to show its lid to user

9/
* add .isDragging to collect() and modify List render() to show itself based on isDragging using short-circuiting logical operations
  * it should now look like I pick up the list and drag it

10/
* modify for-loop in Board to use .renderColumn(i + 1, lists.indexOf(lists[i]))) for .renderColumn(colID, listItemID)

11/
* setup Column as DropTarget()
* define an action in actions.js and dispatch it from hover() [inside dropTargetContract]
* adjust reducer to know about the action



class ListCtn extends Component{
  componentWillReceiveProps(nextProps){
    const { dragSource, reorder } = this.props;

    // enter handler
    if (!this.props.isOver && nextProps.isOver) {
      return reorder(dragSource.index, this.props.index)
    }
  }

  render(){
    // props injected by React DnD as defined by collect()
    const { connectDropTarget } = this.props;

    // false && (non-bool) returns false, ignores (non-bool)
    // aka to return the this.props.id, isOver must be true ...
    return connectDropTarget(
      <div className="column">
        { this.props.children }
      </div>
    )
  }
}



// specifies the Drop Target contract specification
// nothing is really required inside this spec
const dropTargetContract = {
  drop(props, monitor){
    // return the data describing the droppable item => column index
    const dropTarget = { index: props.index }
    return dropTarget
  }
}

// collect() tells DropTarget()() which props to inject into your component
// collect() called inside DropTarget()() is using DropTargetMonitor as monitor param
function collect(connector, monitor){
  return {
    // connectDropTarget() will be called inside render(), to let React DnD handle the drop events
    connectDropTarget: connector.dropTarget(),
    isOver: monitor.isOver(),
    isOverCurrent: monitor.isOver({ shallow: true }),
    dragSource: monitor.getItem()
  }
}



X/ Notable 1
* List component organized as empty <div> in plain <div> gives you an interesting 'return' gradually effect in chrome 64.0.3282.140
    return connectDragSource(
      <div>
        <div className="list"></div>
      </div>
    )
* if it's not empty, it renders the return abruptly as usual =/
